% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colorize.R
\name{set_modsem_colors}
\alias{set_modsem_colors}
\title{Set Color Scheme for Numeric Highlighting in \code{\link{modsem}}}
\usage{
set_modsem_colors(
  numeric.positive = "orange1",
  numeric.negative = "orange1",
  active = TRUE
)
}
\arguments{
\item{numeric.positive}{A color name (as accepted by the \code{cli} package or base \code{R}) 
to be used for positive numeric values. Default is \code{"orange1"}.}

\item{numeric.negative}{A color name for negative numeric values. Default is \code{"orange1"}.}

\item{active}{Logical; if \code{TRUE}, color highlighting will be activated. If \code{FALSE}, 
any color-related behavior is disabled, regardless of color validity.}
}
\value{
Logical: \code{TRUE} if colors were successfully set and activated, \code{FALSE} if deactivated.
}
\description{
Sets the ANSI color styles for positive and negative numeric values to be used 
in text output functions in \code{\link{modsem}}. Also activates or deactivates color usage.
}
\details{
This function sets both the string names of the color (\code{numeric.positive}, \code{numeric.negative})
and their corresponding compiled ANSI styles via \code{cli::make_ansi_style()}, storing them in
the `MODSEM_COLORS` environment.

If either color is not a valid \code{R} color (i.e., not in \code{grDevices::colors()}), or if \code{active} is 
\code{FALSE}, then highlighting is disabled and the function returns \code{FALSE}.
}
\examples{
m1 <- "
# Outer Model
  X =~ x1 + x2 + x3
  Z =~ z1 + z2 + z3
  Y =~ y1 + y2 + y3
# Inner Model
  Y ~ X + Z + X:Z
"

est <- modsem(m1, data = oneInt)

# Activate Color Theme with default colors
set_modsem_colors()
print(summary(est))

# Change colors
set_modsem_colors(numeric.positive = "green", numeric.negative = "red", active = TRUE)
print(summary(est))

# Disable colors
set_modsem_colors(active = FALSE)
print(summary(est))
}
