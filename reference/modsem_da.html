<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Interaction between latent variables using lms and qml approaches — modsem_da • modsem</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Interaction between latent variables using lms and qml approaches — modsem_da"><meta name="description" content='modsem_da() is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches ("dblcent", "rca", "uca",
"ca", "pind")
2. Distributionally based approaches ("lms", "qml").
modsem_da() handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.
NOTE: Run default_settings_da to see default arguments.'><meta property="og:description" content='modsem_da() is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches ("dblcent", "rca", "uca",
"ca", "pind")
2. Distributionally based approaches ("lms", "qml").
modsem_da() handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.
NOTE: Run default_settings_da to see default arguments.'></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">modsem</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.11</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/modsem.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/customizing.html">customizing interaction terms</a></li>
    <li><a class="dropdown-item" href="../articles/estimation_lms.html">estimation alternatives using the LMS approach</a></li>
    <li><a class="dropdown-item" href="../articles/fit_measures_da.html">fit measures for LMS and QML</a></li>
    <li><a class="dropdown-item" href="../articles/higher_order_interactions.html">higher order interactions</a></li>
    <li><a class="dropdown-item" href="../articles/interaction_two_etas.html">interaction effects between endogenous variables</a></li>
    <li><a class="dropdown-item" href="../articles/lavaan.html">using lavaan functions</a></li>
    <li><a class="dropdown-item" href="../articles/lms_qml.html">LMS and QML approaches</a></li>
    <li><a class="dropdown-item" href="../articles/meanstructure_lms_qml.html">non-centered interaction terms (LMS and QML)</a></li>
    <li><a class="dropdown-item" href="../articles/methods.html">methods</a></li>
    <li><a class="dropdown-item" href="../articles/observed_lms_qml.html">observed variables in the LMS- and QML approach</a></li>
    <li><a class="dropdown-item" href="../articles/plot_interactions.html">plotting interaction effects</a></li>
    <li><a class="dropdown-item" href="../articles/quadratic.html">quadratic effects</a></li>
    <li><a class="dropdown-item" href="../articles/relcorr_items.html">reliability-corrected single items</a></li>
    <li><a class="dropdown-item" href="../articles/simple_slopes.html">simple slopes analysis</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Interaction between latent variables using lms and qml approaches</h1>

      <div class="d-none name"><code>modsem_da.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>modsem_da()</code> is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches (<code>"dblcent"</code>, <code>"rca"</code>, <code>"uca"</code>,
<code>"ca"</code>, <code>"pind"</code>)
2. Distributionally based approaches (<code>"lms"</code>, <code>"qml"</code>).</p>
<p><code>modsem_da()</code> handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.</p>
<p><strong>NOTE</strong>: Run <code><a href="default_settings_da.html">default_settings_da</a></code> to see default arguments.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">modsem_da</span><span class="op">(</span></span>
<span>  model.syntax <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  method <span class="op">=</span> <span class="st">"lms"</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  optimize <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  nodes <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  impute.na <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  convergence.abs <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  convergence.rel <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  optimizer <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  center.data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize.data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize.out <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  mean.observed <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  cov.syntax <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  double <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  calc.se <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  FIM <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  EFIM.S <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  OFIM.hessian <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  EFIM.parametric <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  robust.se <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  R.max <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  max.iter <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  max.step <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  start <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  epsilon <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  quad.range <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  adaptive.quad <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  adaptive.frequency <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  n.threads <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  algorithm <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  em.control <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  rcs <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  rcs.choose <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  orthogonal.x <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  orthogonal.y <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  auto.fix.first <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  auto.fix.single <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-model-syntax">model.syntax<a class="anchor" aria-label="anchor" href="#arg-model-syntax"></a></dt>
<dd><p><code>lavaan</code> syntax</p></dd>


<dt id="arg-data">data<a class="anchor" aria-label="anchor" href="#arg-data"></a></dt>
<dd><p>dataframe</p></dd>


<dt id="arg-method">method<a class="anchor" aria-label="anchor" href="#arg-method"></a></dt>
<dd><p>method to use:
<code>"lms"</code> = latent model structural equations (not passed to <code>lavaan</code>).
<code>"qml"</code> = quasi maximum likelihood estimation of latent model structural equations (not passed to <code>lavaan</code>).</p></dd>


<dt id="arg-verbose">verbose<a class="anchor" aria-label="anchor" href="#arg-verbose"></a></dt>
<dd><p>should estimation progress be shown</p></dd>


<dt id="arg-optimize">optimize<a class="anchor" aria-label="anchor" href="#arg-optimize"></a></dt>
<dd><p>should starting parameters be optimized</p></dd>


<dt id="arg-nodes">nodes<a class="anchor" aria-label="anchor" href="#arg-nodes"></a></dt>
<dd><p>number of quadrature nodes (points of integration) used in <code>lms</code>,
increased number gives better estimates but slower computation. How many are needed depends on the complexity of the model.
For simple models, somewhere between 16-24 nodes should be enough; for more complex models, higher numbers may be needed.
For models where there is an interaction effect between an endogenous and exogenous variable,
the number of nodes should be at least 32, but practically (e.g., ordinal/skewed data), more than 32 is recommended. In cases
where data is non-normal, it might be better to use the <code>qml</code> approach instead.
You can also consider setting <code>adaptive.quad = TRUE</code>.</p></dd>


<dt id="arg-impute-na">impute.na<a class="anchor" aria-label="anchor" href="#arg-impute-na"></a></dt>
<dd><p>Should missing values be imputed? If <code>FALSE</code> missing values
are removed case-wise. If <code>TRUE</code> values are imputed using <code><a href="https://rdrr.io/pkg/Amelia/man/amelia.html" class="external-link">Amelia::amelia</a></code>.
Default is <code>FALSE</code>. If you want more fine-grained control over how the missing data
is imputed, you should consider imputing it yourself.</p></dd>


<dt id="arg-convergence-abs">convergence.abs<a class="anchor" aria-label="anchor" href="#arg-convergence-abs"></a></dt>
<dd><p>Absolute convergence criterion.
Lower values give better estimates but slower computation. Not relevant when
using the QML approach. For the LMS approach the EM-algorithm stops whenever
the relative or absolute convergence criterion is reached.</p></dd>


<dt id="arg-convergence-rel">convergence.rel<a class="anchor" aria-label="anchor" href="#arg-convergence-rel"></a></dt>
<dd><p>Relative convergence criterion.
Lower values give better estimates but slower computation.
For the LMS approach the EM-algorithm stops whenever
the relative or absolute convergence criterion is reached.</p></dd>


<dt id="arg-optimizer">optimizer<a class="anchor" aria-label="anchor" href="#arg-optimizer"></a></dt>
<dd><p>optimizer to use, can be either <code>"nlminb"</code> or <code>"L-BFGS-B"</code>. For LMS, <code>"nlminb"</code> is recommended.
For QML, <code>"L-BFGS-B"</code> may be faster if there is a large number of iterations, but slower if there are few iterations.</p></dd>


<dt id="arg-center-data">center.data<a class="anchor" aria-label="anchor" href="#arg-center-data"></a></dt>
<dd><p>should data be centered before fitting model</p></dd>


<dt id="arg-standardize-data">standardize.data<a class="anchor" aria-label="anchor" href="#arg-standardize-data"></a></dt>
<dd><p>should data be scaled before fitting model, will be overridden by
  <code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
<code><a href="standardize_model.html">standardize_model</a></code> <code><a href="standardized_estimates.html">standardized_estimates</a></code>, <code>summary(&lt;modsem_da-object&gt;, standardize=TRUE)</code></p></dd>


<dt id="arg-standardize-out">standardize.out<a class="anchor" aria-label="anchor" href="#arg-standardize-out"></a></dt>
<dd><p>should output be standardized (note will alter the relationships of
  parameter constraints since parameters are scaled unevenly, even if they
  have the same label). This does not alter the estimation of the model, only the
  output.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
<code><a href="standardized_estimates.html">standardized_estimates</a></code>.</p></dd>


<dt id="arg-standardize">standardize<a class="anchor" aria-label="anchor" href="#arg-standardize"></a></dt>
<dd><p>will standardize the data before fitting the model, remove the mean
  structure of the observed variables, and standardize the output. Note that <code>standardize.data</code>,
  <code>mean.observed</code>, and <code>standardize.out</code> will be overridden by <code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
  <code><a href="standardized_estimates.html">standardized_estimates</a></code>.</p></dd>


<dt id="arg-mean-observed">mean.observed<a class="anchor" aria-label="anchor" href="#arg-mean-observed"></a></dt>
<dd><p>should the mean structure of the observed variables be estimated?
  This will be overridden by <code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: Not recommended unless you know what you are doing.</p></dd>


<dt id="arg-cov-syntax">cov.syntax<a class="anchor" aria-label="anchor" href="#arg-cov-syntax"></a></dt>
<dd><p>model syntax for implied covariance matrix (see <code><a href="../articles/interaction_two_etas.html">vignette("interaction_two_etas", "modsem")</a></code>)</p></dd>


<dt id="arg-double">double<a class="anchor" aria-label="anchor" href="#arg-double"></a></dt>
<dd><p>try to double the number of dimensions of integration used in LMS,
this will be extremely slow but should be more similar to <code>mplus</code>.</p></dd>


<dt id="arg-calc-se">calc.se<a class="anchor" aria-label="anchor" href="#arg-calc-se"></a></dt>
<dd><p>should standard errors be computed? <strong>NOTE</strong>: If <code>FALSE</code>, the information matrix will not be computed either.</p></dd>


<dt id="arg-fim">FIM<a class="anchor" aria-label="anchor" href="#arg-fim"></a></dt>
<dd><p>should the Fisher information matrix be calculated using the observed or expected values? Must be either <code>"observed"</code> or <code>"expected"</code>.</p></dd>


<dt id="arg-efim-s">EFIM.S<a class="anchor" aria-label="anchor" href="#arg-efim-s"></a></dt>
<dd><p>if the expected Fisher information matrix is computed, <code>EFIM.S</code> selects the number of Monte Carlo samples. Defaults to 100.
<strong>NOTE</strong>: This number should likely be increased for better estimates (e.g., 1000), but it might drasticly increase computation time.</p></dd>


<dt id="arg-ofim-hessian">OFIM.hessian<a class="anchor" aria-label="anchor" href="#arg-ofim-hessian"></a></dt>
<dd><p>Logical. If <code>TRUE</code> (default) standard errors are
  based on the negative Hessian (observed Fisher information).
  If <code>FALSE</code> they come from the outer product
  of individual score vectors (OPG). For correctly specified models,
  these two matrices are asymptotically equivalent; yielding nearly identical
  standard errors in large samples. The Hessian usually shows smaller finite-sample
  variance (i.e., it's more consistent), and is therefore the default.</p>
<p>Note, that the Hessian is not always positive definite, and is more computationally
  expensive to calculate. The OPG should always be positive definite, and a lot
  faster to compute. If the model is correctly specified, and the sample size is large,
  then the two should yield similar results, and switching to the OPG can save a
  lot of time. Note, that the required sample size depends on the complexity of the model.</p>
<p>A large difference between Hessian and OPG suggests misspecification, and
  <code>robust.se = TRUE</code> should be set to obtain sandwich (robust) standard errors.</p></dd>


<dt id="arg-efim-parametric">EFIM.parametric<a class="anchor" aria-label="anchor" href="#arg-efim-parametric"></a></dt>
<dd><p>should data for calculating the expected Fisher information matrix be
simulated parametrically (simulated based on the assumptions and implied parameters
from the model), or non-parametrically (stochastically sampled)? If you believe that
normality assumptions are violated, <code>EFIM.parametric = FALSE</code> might be the better option.</p></dd>


<dt id="arg-robust-se">robust.se<a class="anchor" aria-label="anchor" href="#arg-robust-se"></a></dt>
<dd><p>should robust standard errors be computed, using the sandwich estimator?</p></dd>


<dt id="arg-r-max">R.max<a class="anchor" aria-label="anchor" href="#arg-r-max"></a></dt>
<dd><p>Maximum population size (not sample size) used in the calculated of the expected
fischer information matrix.</p></dd>


<dt id="arg-max-iter">max.iter<a class="anchor" aria-label="anchor" href="#arg-max-iter"></a></dt>
<dd><p>maximum number of iterations.</p></dd>


<dt id="arg-max-step">max.step<a class="anchor" aria-label="anchor" href="#arg-max-step"></a></dt>
<dd><p>maximum steps for the M-step in the EM algorithm (LMS).</p></dd>


<dt id="arg-start">start<a class="anchor" aria-label="anchor" href="#arg-start"></a></dt>
<dd><p>starting parameters.</p></dd>


<dt id="arg-epsilon">epsilon<a class="anchor" aria-label="anchor" href="#arg-epsilon"></a></dt>
<dd><p>finite difference for numerical derivatives.</p></dd>


<dt id="arg-quad-range">quad.range<a class="anchor" aria-label="anchor" href="#arg-quad-range"></a></dt>
<dd><p>range in z-scores to perform numerical integration in LMS using,
when using quasi-adaptive Gaussian-Hermite Quadratures. By default <code>Inf</code>, such that <code>f(t)</code> is integrated from -Inf to Inf,
but this will likely be inefficient and pointless at a large number of nodes. Nodes outside
<code>+/- quad.range</code> will be ignored.</p></dd>


<dt id="arg-adaptive-quad">adaptive.quad<a class="anchor" aria-label="anchor" href="#arg-adaptive-quad"></a></dt>
<dd><p>should a quasi adaptive quadrature be used? If <code>TRUE</code>, the quadrature nodes will be adapted to the data.
If <code>FALSE</code>, the quadrature nodes will be fixed. Default is <code>FALSE</code>. The adaptive quadrature does not fit an adaptive
quadrature to each participant, but instead tries to place more nodes where posterior distribution is highest. Compared with a
fixed Gauss Hermite quadrature this usually means that less nodes are placed at the tails of the distribution.</p></dd>


<dt id="arg-adaptive-frequency">adaptive.frequency<a class="anchor" aria-label="anchor" href="#arg-adaptive-frequency"></a></dt>
<dd><p>How often should the quasi-adaptive quadrature be calculated? Defaults to 3, meaning
that it is recalculated every third EM-iteration.</p></dd>


<dt id="arg-n-threads">n.threads<a class="anchor" aria-label="anchor" href="#arg-n-threads"></a></dt>
<dd><p>number of threads to use for parallel processing. If <code>NULL</code>, it will use &lt;= 2 threads.
If an integer is specified, it will use that number of threads (e.g., <code>n.threads = 4</code> will use 4 threads).
If <code>"default"</code>, it will use the default number of threads (2).
If <code>"max"</code>, it will use all available threads, <code>"min"</code> will use 1 thread.</p></dd>


<dt id="arg-algorithm">algorithm<a class="anchor" aria-label="anchor" href="#arg-algorithm"></a></dt>
<dd><p>algorithm to use for the EM algorithm. Can be either <code>"EM"</code> or <code>"EMA"</code>.
<code>"EM"</code> is the standard EM algorithm. <code>"EMA"</code> is an
accelerated EM procedure that uses Quasi-Newton and Fisher Scoring
optimization steps when needed. Default is <code>"EM"</code>.</p></dd>


<dt id="arg-em-control">em.control<a class="anchor" aria-label="anchor" href="#arg-em-control"></a></dt>
<dd><p>a list of control parameters for the EM algorithm. See <code><a href="default_settings_da.html">default_settings_da</a></code> for defaults.</p></dd>


<dt id="arg-rcs">rcs<a class="anchor" aria-label="anchor" href="#arg-rcs"></a></dt>
<dd><p>Should latent variable indicators be replaced with reliablity-corrected
single item indicators instead? See <code><a href="relcorr_single_item.html">relcorr_single_item</a></code>.</p></dd>


<dt id="arg-rcs-choose">rcs.choose<a class="anchor" aria-label="anchor" href="#arg-rcs-choose"></a></dt>
<dd><p>Which latent variables should get their indicators replaced with
reliablity-reliability corrected single items? Corresponds to the <code>choose</code>
argument in <code><a href="relcorr_single_item.html">relcorr_single_item</a></code>.</p></dd>


<dt id="arg-orthogonal-x">orthogonal.x<a class="anchor" aria-label="anchor" href="#arg-orthogonal-x"></a></dt>
<dd><p>If <code>TRUE</code>, all covariances among exogenous latent variables only are set to zero.
Default is <code>FALSE</code>.</p></dd>


<dt id="arg-orthogonal-y">orthogonal.y<a class="anchor" aria-label="anchor" href="#arg-orthogonal-y"></a></dt>
<dd><p>If <code>TRUE</code>, all covariances among endogenous latent variables only are set to zero.
If <code>FALSE</code> residual covariances are added between pure endogenous variables;
those that are predicted by no other endogenous variable in the structural model.
Default is <code>FALSE</code>.</p></dd>


<dt id="arg-auto-fix-first">auto.fix.first<a class="anchor" aria-label="anchor" href="#arg-auto-fix-first"></a></dt>
<dd><p>If <code>TRUE</code> the factor loading of the first indicator, for
a given latent variable is fixed to <code>1</code>. If <code>FALSE</code> no loadings are fixed
(automatically). Note that that this might make it such that the model no longer is
identified. Default is <code>TRUE</code>. <strong>NOTE</strong> this behaviour is overridden
if the first loading is labelled, where it gets treated as a free parameter instead. This
differs from the default behaviour in <code>lavaan</code>.</p></dd>


<dt id="arg-auto-fix-single">auto.fix.single<a class="anchor" aria-label="anchor" href="#arg-auto-fix-single"></a></dt>
<dd><p>If <code>TRUE</code>, the residual variance of
an observed indicator is set to zero if it is the only indicator of a latent variable.
If <code>FALSE</code> the residual variance is not fixed to zero, and treated as a free parameter
of the model. Default if <code>TRUE</code>. <strong>NOTE</strong> this behaviour is overridden
if the first loading is labelled, where it gets treated as a free parameter instead.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>additional arguments to be passed to the estimation function.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p><code>modsem_da</code> object</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://modsem.org" class="external-link">modsem</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># For more examples, check README and/or GitHub.</span></span></span>
<span class="r-in"><span><span class="co"># One interaction</span></span></span>
<span class="r-in"><span><span class="va">m1</span> <span class="op">&lt;-</span> <span class="st">"</span></span></span>
<span class="r-in"><span><span class="st">  # Outer Model</span></span></span>
<span class="r-in"><span><span class="st">  X =~ x1 + x2 +x3</span></span></span>
<span class="r-in"><span><span class="st">  Y =~ y1 + y2 + y3</span></span></span>
<span class="r-in"><span><span class="st">  Z =~ z1 + z2 + z3</span></span></span>
<span class="r-in"><span><span class="st"></span></span></span>
<span class="r-in"><span><span class="st">  # Inner model</span></span></span>
<span class="r-in"><span><span class="st">  Y ~ X + Z + X:Z</span></span></span>
<span class="r-in"><span><span class="st">"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="co"># QML Approach</span></span></span>
<span class="r-in"><span><span class="va">est_qml</span> <span class="op">&lt;-</span> <span class="fu">modsem_da</span><span class="op">(</span><span class="va">m1</span>, <span class="va">oneInt</span>, method <span class="op">=</span> <span class="st">"qml"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est_qml</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Theory Of Planned Behavior</span></span></span>
<span class="r-in"><span><span class="va">tpb</span> <span class="op">&lt;-</span> <span class="st">"</span></span></span>
<span class="r-in"><span><span class="st"># Outer Model (Based on Hagger et al., 2007)</span></span></span>
<span class="r-in"><span><span class="st">  ATT =~ att1 + att2 + att3 + att4 + att5</span></span></span>
<span class="r-in"><span><span class="st">  SN =~ sn1 + sn2</span></span></span>
<span class="r-in"><span><span class="st">  PBC =~ pbc1 + pbc2 + pbc3</span></span></span>
<span class="r-in"><span><span class="st">  INT =~ int1 + int2 + int3</span></span></span>
<span class="r-in"><span><span class="st">  BEH =~ b1 + b2</span></span></span>
<span class="r-in"><span><span class="st"></span></span></span>
<span class="r-in"><span><span class="st"># Inner Model (Based on Steinmetz et al., 2011)</span></span></span>
<span class="r-in"><span><span class="st">  # Covariances</span></span></span>
<span class="r-in"><span><span class="st">  ATT ~~ SN + PBC</span></span></span>
<span class="r-in"><span><span class="st">  PBC ~~ SN</span></span></span>
<span class="r-in"><span><span class="st">  # Causal Relationships</span></span></span>
<span class="r-in"><span><span class="st">  INT ~ ATT + SN + PBC</span></span></span>
<span class="r-in"><span><span class="st">  BEH ~ INT + PBC</span></span></span>
<span class="r-in"><span><span class="st">  BEH ~ INT:PBC</span></span></span>
<span class="r-in"><span><span class="st">"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># LMS Approach</span></span></span>
<span class="r-in"><span><span class="va">est_lms</span> <span class="op">&lt;-</span> <span class="fu">modsem_da</span><span class="op">(</span><span class="va">tpb</span>, data <span class="op">=</span> <span class="va">TPB</span>, method <span class="op">=</span> <span class="va">lms</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est_lms</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kjell Solem Slupphaug.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

