<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Interaction between latent variables using lms and qml approaches — modsem_da • modsem</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Interaction between latent variables using lms and qml approaches — modsem_da"><meta name="description" content='modsem_da() is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches ("dblcent", "rca", "uca",
"ca", "pind")
2. Distributionally based approaches ("lms", "qml").
modsem_da() handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.
NOTE: Run default_settings_da to see default arguments.'><meta property="og:description" content='modsem_da() is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches ("dblcent", "rca", "uca",
"ca", "pind")
2. Distributionally based approaches ("lms", "qml").
modsem_da() handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.
NOTE: Run default_settings_da to see default arguments.'></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">modsem</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.4</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/modsem.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/customizing.html">customizing interaction terms</a></li>
    <li><a class="dropdown-item" href="../articles/higher_order_interactions.html">higher order interactions</a></li>
    <li><a class="dropdown-item" href="../articles/interaction_two_etas.html">interaction effects between endogenous variables</a></li>
    <li><a class="dropdown-item" href="../articles/lavaan.html">using lavaan functions</a></li>
    <li><a class="dropdown-item" href="../articles/lms_qml.html">LMS and QML approaches</a></li>
    <li><a class="dropdown-item" href="../articles/methods.html">methods</a></li>
    <li><a class="dropdown-item" href="../articles/observed_lms_qml.html">observed variables in the LMS- and QML approach</a></li>
    <li><a class="dropdown-item" href="../articles/plot_interactions.html">plotting interaction effects</a></li>
    <li><a class="dropdown-item" href="../articles/quadratic.html">quadratic effects</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Interaction between latent variables using lms and qml approaches</h1>

      <div class="d-none name"><code>modsem_da.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>modsem_da()</code> is a function for estimating interaction effects between latent variables
in structural equation models (SEMs) using distributional analytic (DA) approaches.
Methods for estimating interaction effects in SEMs can basically be split into
two frameworks:
1. Product Indicator-based approaches (<code>"dblcent"</code>, <code>"rca"</code>, <code>"uca"</code>,
<code>"ca"</code>, <code>"pind"</code>)
2. Distributionally based approaches (<code>"lms"</code>, <code>"qml"</code>).</p>
<p><code>modsem_da()</code> handles the latter and can estimate models using both QML and LMS,
necessary syntax, and variables for the estimation of models with latent product indicators.</p>
<p><strong>NOTE</strong>: Run <code><a href="default_settings_da.html">default_settings_da</a></code> to see default arguments.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">modsem_da</span><span class="op">(</span></span>
<span>  model.syntax <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  method <span class="op">=</span> <span class="st">"lms"</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  optimize <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  nodes <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  convergence <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  optimizer <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  center.data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize.data <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize.out <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  standardize <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  mean.observed <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  cov.syntax <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  double <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  calc.se <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  FIM <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  EFIM.S <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  OFIM.hessian <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  EFIM.parametric <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  robust.se <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  R.max <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  max.iter <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  max.step <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  fix.estep <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  start <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  epsilon <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  quad.range <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  n.threads <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-model-syntax">model.syntax<a class="anchor" aria-label="anchor" href="#arg-model-syntax"></a></dt>
<dd><p><code>lavaan</code> syntax</p></dd>


<dt id="arg-data">data<a class="anchor" aria-label="anchor" href="#arg-data"></a></dt>
<dd><p>dataframe</p></dd>


<dt id="arg-method">method<a class="anchor" aria-label="anchor" href="#arg-method"></a></dt>
<dd><p>method to use:
<code>"lms"</code> = latent model structural equations (not passed to <code>lavaan</code>).
<code>"qml"</code> = quasi maximum likelihood estimation of latent model structural equations (not passed to <code>lavaan</code>).</p></dd>


<dt id="arg-verbose">verbose<a class="anchor" aria-label="anchor" href="#arg-verbose"></a></dt>
<dd><p>should estimation progress be shown</p></dd>


<dt id="arg-optimize">optimize<a class="anchor" aria-label="anchor" href="#arg-optimize"></a></dt>
<dd><p>should starting parameters be optimized</p></dd>


<dt id="arg-nodes">nodes<a class="anchor" aria-label="anchor" href="#arg-nodes"></a></dt>
<dd><p>number of quadrature nodes (points of integration) used in <code>lms</code>,
increased number gives better estimates but slower computation. How many are needed depends on the complexity of the model.
For simple models, somewhere between 16-24 nodes should be enough; for more complex models, higher numbers may be needed.
For models where there is an interaction effect between an endogenous and exogenous variable,
the number of nodes should be at least 32, but practically (e.g., ordinal/skewed data), more than 32 is recommended. In cases
where data is non-normal, it might be better to use the <code>qml</code> approach instead. For large
numbers of nodes, you might want to change the <code>'quad.range'</code> argument.</p></dd>


<dt id="arg-convergence">convergence<a class="anchor" aria-label="anchor" href="#arg-convergence"></a></dt>
<dd><p>convergence criterion. Lower values give better estimates but slower computation.</p></dd>


<dt id="arg-optimizer">optimizer<a class="anchor" aria-label="anchor" href="#arg-optimizer"></a></dt>
<dd><p>optimizer to use, can be either <code>"nlminb"</code> or <code>"L-BFGS-B"</code>. For LMS, <code>"nlminb"</code> is recommended.
For QML, <code>"L-BFGS-B"</code> may be faster if there is a large number of iterations, but slower if there are few iterations.</p></dd>


<dt id="arg-center-data">center.data<a class="anchor" aria-label="anchor" href="#arg-center-data"></a></dt>
<dd><p>should data be centered before fitting model</p></dd>


<dt id="arg-standardize-data">standardize.data<a class="anchor" aria-label="anchor" href="#arg-standardize-data"></a></dt>
<dd><p>should data be scaled before fitting model, will be overridden by
<code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
<code><a href="standardized_estimates.html">standardized_estimates</a></code>.</p></dd>


<dt id="arg-standardize-out">standardize.out<a class="anchor" aria-label="anchor" href="#arg-standardize-out"></a></dt>
<dd><p>should output be standardized (note will alter the relationships of
parameter constraints since parameters are scaled unevenly, even if they
have the same label). This does not alter the estimation of the model, only the
output.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
<code><a href="standardized_estimates.html">standardized_estimates</a></code>.</p></dd>


<dt id="arg-standardize">standardize<a class="anchor" aria-label="anchor" href="#arg-standardize"></a></dt>
<dd><p>will standardize the data before fitting the model, remove the mean
structure of the observed variables, and standardize the output. Note that <code>standardize.data</code>,
<code>mean.observed</code>, and <code>standardize.out</code> will be overridden by <code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: It is recommended that you estimate the model normally and then standardize the output using
<code><a href="standardized_estimates.html">standardized_estimates</a></code>.</p></dd>


<dt id="arg-mean-observed">mean.observed<a class="anchor" aria-label="anchor" href="#arg-mean-observed"></a></dt>
<dd><p>should the mean structure of the observed variables be estimated?
This will be overridden by <code>standardize</code> if <code>standardize</code> is set to <code>TRUE</code>.</p>
<p><strong>NOTE</strong>: Not recommended unless you know what you are doing.</p></dd>


<dt id="arg-cov-syntax">cov.syntax<a class="anchor" aria-label="anchor" href="#arg-cov-syntax"></a></dt>
<dd><p>model syntax for implied covariance matrix (see <code><a href="../articles/interaction_two_etas.html">vignette("interaction_two_etas", "modsem")</a></code>)</p></dd>


<dt id="arg-double">double<a class="anchor" aria-label="anchor" href="#arg-double"></a></dt>
<dd><p>try to double the number of dimensions of integration used in LMS,
this will be extremely slow but should be more similar to <code>mplus</code>.</p></dd>


<dt id="arg-calc-se">calc.se<a class="anchor" aria-label="anchor" href="#arg-calc-se"></a></dt>
<dd><p>should standard errors be computed? <strong>NOTE</strong>: If <code>FALSE</code>, the information matrix will not be computed either.</p></dd>


<dt id="arg-fim">FIM<a class="anchor" aria-label="anchor" href="#arg-fim"></a></dt>
<dd><p>should the Fisher information matrix be calculated using the observed or expected values? Must be either <code>"observed"</code> or <code>"expected"</code>.</p></dd>


<dt id="arg-efim-s">EFIM.S<a class="anchor" aria-label="anchor" href="#arg-efim-s"></a></dt>
<dd><p>if the expected Fisher information matrix is computed, <code>EFIM.S</code> selects the number of Monte Carlo samples. Defaults to 100.
<strong>NOTE</strong>: This number should likely be increased for better estimates (e.g., 1000-10000), but it might drasticly increase computation time.</p></dd>


<dt id="arg-ofim-hessian">OFIM.hessian<a class="anchor" aria-label="anchor" href="#arg-ofim-hessian"></a></dt>
<dd><p>should the observed Fisher information be computed using the Hessian? If <code>FALSE</code>, it is computed using the gradient.</p></dd>


<dt id="arg-efim-parametric">EFIM.parametric<a class="anchor" aria-label="anchor" href="#arg-efim-parametric"></a></dt>
<dd><p>should data for calculating the expected Fisher information matrix be
simulated parametrically (simulated based on the assumptions and implied parameters
from the model), or non-parametrically (stochastically sampled)? If you believe that
normality assumptions are violated, <code>EFIM.parametric = FALSE</code> might be the better option.</p></dd>


<dt id="arg-robust-se">robust.se<a class="anchor" aria-label="anchor" href="#arg-robust-se"></a></dt>
<dd><p>should robust standard errors be computed? Meant to be used for QML,
can be unreliable with the LMS approach.</p></dd>


<dt id="arg-r-max">R.max<a class="anchor" aria-label="anchor" href="#arg-r-max"></a></dt>
<dd><p>Maximum population size (not sample size) used in the calculated of the expected
fischer information matrix.</p></dd>


<dt id="arg-max-iter">max.iter<a class="anchor" aria-label="anchor" href="#arg-max-iter"></a></dt>
<dd><p>maximum number of iterations.</p></dd>


<dt id="arg-max-step">max.step<a class="anchor" aria-label="anchor" href="#arg-max-step"></a></dt>
<dd><p>maximum steps for the M-step in the EM algorithm (LMS).</p></dd>


<dt id="arg-fix-estep">fix.estep<a class="anchor" aria-label="anchor" href="#arg-fix-estep"></a></dt>
<dd><p>if <code>TRUE</code>, the E-step will be fixed, and the prior probabilities will be set to the best prior probabilities,
if the log-likelihood decreases for more than 30 iterations.</p></dd>


<dt id="arg-start">start<a class="anchor" aria-label="anchor" href="#arg-start"></a></dt>
<dd><p>starting parameters.</p></dd>


<dt id="arg-epsilon">epsilon<a class="anchor" aria-label="anchor" href="#arg-epsilon"></a></dt>
<dd><p>finite difference for numerical derivatives.</p></dd>


<dt id="arg-quad-range">quad.range<a class="anchor" aria-label="anchor" href="#arg-quad-range"></a></dt>
<dd><p>range in z-scores to perform numerical integration in LMS using
Gaussian-Hermite Quadratures. By default <code>Inf</code>, such that <code>f(t)</code> is integrated from -Inf to Inf,
but this will likely be inefficient and pointless at a large number of nodes. Nodes outside
<code>+/- quad.range</code> will be ignored.</p></dd>


<dt id="arg-n-threads">n.threads<a class="anchor" aria-label="anchor" href="#arg-n-threads"></a></dt>
<dd><p>number of cores to use for parallel processing. If <code>NULL</code>, it will use &lt;= 2 threads.
If an integer is specified, it will use that number of threads (e.g., <code>n.threads = 4</code> will use 4 threads).
If <code>"default"</code>, it will use the default number of threads (2).
If <code>"max"</code>, it will use all available threads, <code>"min"</code> will use 1 thread.</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>additional arguments to be passed to the estimation function.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p><code>modsem_da</code> object</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://modsem.org" class="external-link">modsem</a></span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># For more examples, check README and/or GitHub.</span></span></span>
<span class="r-in"><span><span class="co"># One interaction</span></span></span>
<span class="r-in"><span><span class="va">m1</span> <span class="op">&lt;-</span> <span class="st">"</span></span></span>
<span class="r-in"><span><span class="st">  # Outer Model</span></span></span>
<span class="r-in"><span><span class="st">  X =~ x1 + x2 +x3</span></span></span>
<span class="r-in"><span><span class="st">  Y =~ y1 + y2 + y3</span></span></span>
<span class="r-in"><span><span class="st">  Z =~ z1 + z2 + z3</span></span></span>
<span class="r-in"><span><span class="st"></span></span></span>
<span class="r-in"><span><span class="st">  # Inner model</span></span></span>
<span class="r-in"><span><span class="st">  Y ~ X + Z + X:Z</span></span></span>
<span class="r-in"><span><span class="st">"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="kw">if</span> <span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span> <span class="op">{</span> <span class="co"># \dontrun{</span></span></span>
<span class="r-in"><span><span class="co"># QML Approach</span></span></span>
<span class="r-in"><span><span class="va">est1</span> <span class="op">&lt;-</span> <span class="fu">modsem_da</span><span class="op">(</span><span class="va">m1</span>, <span class="va">oneInt</span>, method <span class="op">=</span> <span class="st">"qml"</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">est1</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Theory Of Planned Behavior</span></span></span>
<span class="r-in"><span><span class="va">tpb</span> <span class="op">&lt;-</span> <span class="st">"</span></span></span>
<span class="r-in"><span><span class="st"># Outer Model (Based on Hagger et al., 2007)</span></span></span>
<span class="r-in"><span><span class="st">  ATT =~ att1 + att2 + att3 + att4 + att5</span></span></span>
<span class="r-in"><span><span class="st">  SN =~ sn1 + sn2</span></span></span>
<span class="r-in"><span><span class="st">  PBC =~ pbc1 + pbc2 + pbc3</span></span></span>
<span class="r-in"><span><span class="st">  INT =~ int1 + int2 + int3</span></span></span>
<span class="r-in"><span><span class="st">  BEH =~ b1 + b2</span></span></span>
<span class="r-in"><span><span class="st"></span></span></span>
<span class="r-in"><span><span class="st"># Inner Model (Based on Steinmetz et al., 2011)</span></span></span>
<span class="r-in"><span><span class="st">  # Covariances</span></span></span>
<span class="r-in"><span><span class="st">  ATT ~~ SN + PBC</span></span></span>
<span class="r-in"><span><span class="st">  PBC ~~ SN</span></span></span>
<span class="r-in"><span><span class="st">  # Causal Relationships</span></span></span>
<span class="r-in"><span><span class="st">  INT ~ ATT + SN + PBC</span></span></span>
<span class="r-in"><span><span class="st">  BEH ~ INT + PBC</span></span></span>
<span class="r-in"><span><span class="st">  BEH ~ INT:PBC</span></span></span>
<span class="r-in"><span><span class="st">"</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># LMS Approach</span></span></span>
<span class="r-in"><span><span class="va">estTpb</span> <span class="op">&lt;-</span> <span class="fu">modsem_da</span><span class="op">(</span><span class="va">tpb</span>, data <span class="op">=</span> <span class="va">TPB</span>, method <span class="op">=</span> <span class="va">lms</span>, EFIM.S <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">estTpb</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="op">}</span> <span class="co"># }</span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kjell Solem Slupphaug.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

